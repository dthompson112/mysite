-- MySQL dump 10.13  Distrib 5.5.47, for debian-linux-gnu (i686)
--
-- Host: localhost    Database: projects
-- ------------------------------------------------------
-- Server version	5.5.47-0ubuntu0.14.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `files`
--

DROP TABLE IF EXISTS `files`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `files` (
  `file_data` text,
  `file_name` varchar(45) NOT NULL,
  `file_id` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`file_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `files`
--

LOCK TABLES `files` WRITE;
/*!40000 ALTER TABLE `files` DISABLE KEYS */;
INSERT INTO `files` VALUES ('// HashSet.hpp\n//\n\n#ifndef HASHSET_HPP\n#define HASHSET_HPP\n\n#include <functional>\n#include \"Set.hpp\"\n#include <vector>\n\n\ntemplate <typename T>\nstruct HashNode\n{\n\n    T info;\n   HashNode<T> * next;\n\n    HashNode()\n    {\n        next = nullptr;\n    }\n    \n    HashNode(T input)\n    {\n        info = input;\n        next = nullptr;\n    }\n\n    HashNode(T input, HashNode<T>* newNext)\n    {\n        info = input;\n        next = newNext;\n    }\n};\n\n\ntemplate <typename T>\nclass HashSet : public Set<T>\n{\npublic:\n    // The default capacity of the HashSet before anything has been\n    // added to it.\n    static constexpr unsigned int DEFAULT_CAPACITY = 10;\n\n    // A HashFunction \n    typedef std::function<unsigned int(const T&)> HashFunction;\n\npublic:\n    // Initializes a HashSet to be empty, so that it will use the given\n    // hash function whenever it needs to hash an element.\n    HashSet(HashFunction hashFunction);\n\n    // Cleans up the HashSet so that it leaks no memory.\n    virtual ~HashSet();\n\n    // Initializes a new HashSet to be a copy of an existing one.\n    HashSet(const HashSet& s);\n\n    // Assigns an existing HashSet into another.\n    HashSet& operator=(const HashSet& s);\n\n\n    // isImplemented() should be modified to return true if you\'ve\n    // decided to implement a HashSet, false otherwise.\n    virtual bool isImplemented() const;\n\n\n    // add() adds an element to the set.  If the element is already in the set,\n    // this function has no effect.  This function triggers a resizing of the\n    // array when the ratio of size to capacity would exceed 0.8.  In the case\n    // where the array is resized, this function runs in linear time (with\n    // respect to the number of elements, assuming a good hash function);\n    // otherwise, it runs in constant time (again, assuming a good hash\n    // function).\n    virtual void add(const T& element);\n\n\n    // contains() returns true if the given element is already in the set,\n    // false otherwise.  This function runs in constant time (with respect\n    // to the number of elements, assuming a good hash function).\n    virtual bool contains(const T& element) const;\n\n\n    // size() returns the number of elements in the set.\n    virtual unsigned int size() const;\n\n    //returns ratio of size to capacity\n     double ratio();\n\n    //creates a new has table with double capacity\n    void reHash();\n\n    //free\'s all memeory in table\n   void clearTable();\n    \n   //returns a scaled hash function \n   int getHashFunction(T toHash,int c) const;\n \nprivate:\n    HashFunction hashFunction;\n    int s = 0;\n    int capacity = DEFAULT_CAPACITY;\n    std::vector<HashNode<T>*> * hTable;\n    HashNode<T> * traverse; \n};\n\n\ntemplate<typename T>\nvoid deleteElement(HashNode<T>* element)\n{\n\n   if(element->next != nullptr)\n    deleteElement(element->next);\n    delete element;\n}\n\n\n\ntemplate <typename T>\nHashSet<T>::HashSet(HashFunction hashFunction)\n    : hashFunction{hashFunction}\n{\n    capacity = DEFAULT_CAPACITY;\n    hTable = new std::vector<HashNode<T>*>(capacity, nullptr);\n}\n\ntemplate<typename T>\nvoid HashSet<T>::clearTable()\n{\n    for(int i = 0; i < capacity; ++i)\n    {\n        if(hTable->at(i) != nullptr)\n       deleteElement(hTable->at(i));\n    }\n    delete hTable;\n}\n\n\n\ntemplate <typename T>\nHashSet<T>::~HashSet()\n{\n   clearTable();\n}\n\n\ntemplate <typename T>\nHashSet<T>::HashSet(const HashSet& s)\n    : hashFunction{s.hashFunction}\n{\n\n}\n\n\ntemplate <typename T>\nHashSet<T>& HashSet<T>::operator=(const HashSet& s)\n{\n    if (this != &s)\n    {\n        hashFunction = s.hashFunction;\n    }\n\n     clearTable();   \n     std::vector<HashNode<T>*> * temp = new std::vector<HashNode<T>*>(s.capacity,nullptr);\n   \n   \n   for(int i = 0; i < s.capacity; ++i)\n    {\n        if(s.hTable->at(i) != nullptr)\n        {\n           traverse = s.hTable->at(i);\n           while(traverse != nullptr)\n           {\n            \n             int index = getHashFunction(s.traverse->info);\n             temp->at(index) = new HashNode<T>(traverse->info);\n             traverse = traverse->next;\n           }\n        }\n    }\n    \n    hTable = temp;\n    capacity = s.capacity;\n    return *this;\n}\n\n\ntemplate <typename T>\nbool HashSet<T>::isImplemented() const\n{\n    return true;\n}\n\n\ntemplate<typename T>\ndouble HashSet<T>::ratio()\n{\n   double cap = double(capacity);\n   double sz = double(s);\n    return sz/cap;\n}\n\n\ntemplate<typename T>\nint HashSet<T>::getHashFunction(T toHash,int c) const\n{\n   return hashFunction(toHash) % c;\n}\n\n\ntemplate<typename T>\nvoid HashSet<T>::reHash()\n{\n   int newCap = 2 * capacity;\n   std::vector<HashNode<T>*> * temp = new std::vector<HashNode<T>*>(newCap,nullptr);\n   HashNode<T> * holder = nullptr;\n   \n   for(int i = 0; i < capacity; ++i)\n    {\n        if(hTable->at(i) != nullptr)\n        {\n           traverse = hTable->at(i);\n           while(traverse != nullptr)\n           {\n            \n             int index = getHashFunction(traverse->info,newCap);\n             if(temp->at(index) == nullptr)\n             {\n             temp->at(index) = new HashNode<T>(traverse->info);\n             traverse = traverse->next;\n             }\n             else\n             {\n\n             holder = temp->at(index);\n             temp->at(index) = new HashNode<T>(traverse->info,holder);\n             traverse = traverse->next;\n             }\n           }\n        }\n    }\n\n    holder = nullptr;\n    clearTable();\n    hTable = temp;\n    capacity = newCap;\n\n}\n\n\ntemplate <typename T>\nvoid HashSet<T>::add(const T& element)\n{\n\n    if(ratio() > 0.8)\n    {\n      reHash();\n   }\n    int index = getHashFunction(element,capacity);    \n\n    if(hTable->at(index) == nullptr)\n    {\n        hTable->at(index) = new HashNode<T>{element};\n        ++s;\n   }\n    else\n    {\n        traverse = hTable->at(index);\n        hTable->at(index) = new HashNode<T>{element,traverse};\n        ++s;\n   }\n\n}\n\ntemplate <typename T>\nbool HashSet<T>::contains(const T& element) const\n{\n    \n   int index = getHashFunction(element,capacity);\n    if(hTable->at(index) == nullptr)\n    {\n     return false;\n    }\n    else\n    {\n     const HashNode<T> * temp  =  hTable->at(index);\n      while(temp != nullptr)\n         {\n        if(temp->info == element)\n          return true;\n          temp = temp->next;\n    }\n     temp = nullptr;\n     return false;\n    }\n   \n}\n\n\ntemplate <typename T>\nunsigned int HashSet<T>::size() const\n{\n    return s;\n}','HashSet.hpp',1);
INSERT INTO `files` VALUES ('// SkipListSet.hpp\n\n#ifndef SKIPLISTSET_HPP\n#define SKIPLISTSET_HPP\n\n#include \"Set.hpp\"\n#include <random>\n// SkipListKind indicates a kind of key: a normal one, the special key\n// -INF, or the special key +INF.  It\'s necessary for us to implement\n// the notion of -INF and +INF separately, since we\'re building a class\n// template and not all types of keys would have a reasonable notion of\n// -INF and +INF.\n\nenum class SkipListKind\n{\n    Normal,\n    NegInf,\n    PosInf\n};\n\nstd::default_random_engine engine{std::random_device{}()};\nstd::uniform_int_distribution<int> distribution{0,1};\n\n\n// A SkipListKey represents a single key in a skip list.  It is possible\n// to compare these keys using < or == operators (which are overloaded here)\n// and those comparisons respect the notion of whether each key is normal,\n// -INF, or +INF.\n\ntemplate <typename T>\nclass SkipListKey\n{\npublic:\n    SkipListKey(SkipListKind kind, const T& key);\n    SkipListKey(SkipListKind kind);\n\n    bool operator==(const SkipListKey& other) const;\n    bool operator<(const SkipListKey& other) const;\n    T getKey() const;\n   SkipListKind getKind() const;\n\nprivate:\n    SkipListKind kind;\n    T key;\n};\n\ntemplate<typename T>\nT SkipListKey<T>::getKey() const\n{\n    return key;\n}\n\ntemplate<typename T>\nSkipListKind SkipListKey<T>::getKind() const\n{\n    return kind;\n}\n\ntemplate<typename T>\nSkipListKey<T>::SkipListKey(SkipListKind kind)\n:kind{kind}\n{\n}\n\ntemplate <typename T>\nSkipListKey<T>::SkipListKey(SkipListKind kind, const T& key)\n    : kind{kind}, key{key}\n{\n}\n\n\ntemplate <typename T>\nbool SkipListKey<T>::operator==(const SkipListKey& other) const\n{\n    return kind == other.kind\n        && (kind != SkipListKind::Normal || key == other.key);\n}\n\n\ntemplate <typename T>\nbool SkipListKey<T>::operator<(const SkipListKey& other) const\n{\n    switch (kind)\n    {\n    case SkipListKind::NegInf:\n        return other.kind != SkipListKind::NegInf;\n\n    case SkipListKind::PosInf:\n        return false;\n\n    default: // SkipListKind::Normal\n        return other.kind == SkipListKind::PosInf\n                || (other.kind == SkipListKind::Normal && key < other.key);\n        }\n    }\n\n\n\n    template<typename T>\n    struct SkipNode\n    {\n\n    SkipNode<T> * next;\n    SkipNode<T> * down;\n    SkipListKey<T> k;\n\n    SkipNode():next(nullptr), down(nullptr), k(SkipListKind::PosInf)\n    {\n    }\n\n    SkipNode(SkipListKind k):next(nullptr), down(nullptr), k(k)\n    {\n    }\n\n    SkipNode(SkipListKind s,SkipNode<T> *sn, T element)\n    :k(SkipListKey<T>(s,element)), next(sn), down(nullptr)\n    {\n    }\n\n    SkipNode(SkipListKind s, SkipNode<T> *sn)\n    :next(sn), k(SkipListKey<T>(s))\n    {\n    }\n\n\n    SkipNode(SkipListKind s, SkipNode<T> * n, SkipNode<T> *d, T element)\n    :k(SkipListKey<T>(s,element)), next(n), down(d)\n    {\n    }\n\n    ~SkipNode()\n    {\n        next = nullptr;\n        down = nullptr;\n    }\n\n    };\n\n\n    template <typename T>\n    class SkipListSet : public Set<T>\n    {\n    public:\n        // Initializes an SkipListSet to be empty.\n        SkipListSet();\n\n        // Cleans up the SkipListSet so that it leaks no memory.\n        virtual ~SkipListSet();\n\n        // Initializes a new SkipListSet to be a copy of an existing one.\n        SkipListSet(const SkipListSet& s);\n\n        // Assigns an existing SkipListSet into another.\n        SkipListSet& operator=(const SkipListSet& s);\n\n\n        // isImplemented() should be modified to return true if you\'ve\n        // decided to implement a SkipListSet, false otherwise.\n        virtual bool isImplemented() const;\n\n\n        // add() adds an element to the set.  If the element is already in the set,\n        // this function has no effect.  This function runs in an expected time\n        // of O(log n) (i.e., over the long run, we expect the average to be\n        // O(log n)) with very high probability.\n        virtual void add(const T& element);\n\n\n        // contains() returns true if the given element is already in the set,\n        // false otherwise.  This function runs in an expected time of O(log n)\n        // (i.e., over the long run, we expect the average to be O(log n))\n        // with very high probability.\n        virtual bool contains(const T& element) const;\n\n\n        // size() returns the number of elements in the set.\n        virtual unsigned int size() const;\n\n        //creates a level on the skip list\n        void createLevel(int lv);\n        \n        //inserts a node into the skiplist\n        void insertSkipNode(int level, SkipListKey<T> & slk, SkipNode<T> * sn);\n\n        //resizes the list when the level added is greater than height\n        void resizeSkipList();\n        \n        //used in copy constructor\n         void copySkipList(const SkipNode<T> ** toCopy, const int h);\n    \n\n    private:\n    SkipNode<T> ** levels;\n    //number of nodes\n    int sz = 0;\n    //maximum capacity of levels\n    int height = 10;\n    //number of levels\n    int l = 0;\n    //user for insert to determin weather to jump a level\n    int up = 0;\n\n    //pointers used in functions\n    SkipNode<T> * traverse = nullptr;\n    SkipNode<T> * trailer = nullptr;\n    SkipNode<T> * downTracker = nullptr;\n    SkipNode<T> * temp = nullptr;\n    };\n\n\n    template<typename T>\n    void SkipListSet<T>::resizeSkipList()\n    {\n        SkipNode<T> ** newSL = new SkipNode<T> * [2 * height];\n        for(int i = 0; i < height; ++i)\n        newSL[i] = levels[i];\n        for(int i = height; i < height * 2; ++i)\n        newSL[i] = nullptr;\n\n        for(int i = 0; i < height; ++i)\n        levels[i] = nullptr;\n        delete[] levels;\n\n        levels = newSL;\n        height = 2 * height;\n    }\n\n    template <typename T>\n    void SkipListSet<T>::createLevel(int lv)\n    {\n        if(lv >= height)\n        resizeSkipList();\n\n        if(lv == 0)\n        {\n            levels[lv] = new SkipNode<T>();\n            SkipNode<T> * temp = levels[lv];\n            levels[lv] = new SkipNode<T>(SkipListKind::NegInf, temp);\n            temp = nullptr;\n\n        }\n        else\n        {\n            levels[lv] = new SkipNode<T>();\n            SkipNode<T> * temp = levels[lv];\n            levels[lv] = new SkipNode<T>(SkipListKind::NegInf, temp);\n            levels[lv]->down = levels[lv-1];\n            temp = nullptr;\n        }\n    }\n\n\n    template <typename T>\n    SkipListSet<T>::SkipListSet()\n    {\n        levels = new SkipNode<T> * [height];\n        for(int i = 0; i < height; ++i)\n        levels[i] = nullptr;\n        createLevel(0);\n    }\n\n\n\n    template<typename T>\n    void deleteLevel(SkipNode<T> * sn)\n    {\n\n     if(sn->next != nullptr)\n        deleteLevel(sn->next);\n\n      delete sn;\n    }\n\n    template<typename T>\n    void deleteSkipList(SkipNode<T> ** sn, int h)\n    {\n        for(int i = 0; i < h; ++i)\n        {\n            deleteLevel(sn[i]);\n        }\n    }\n\n    template <typename T>\n    SkipListSet<T>::~SkipListSet()\n    {\n        deleteSkipList(levels, l);\n        delete[] levels;\n        levels = nullptr;\n        traverse = nullptr;\n    }\n\n    template<typename T>\n    void SkipListSet<T>::copySkipList(const SkipNode<T> ** toCopy, const int h)\n    {\n         SkipNode<T> ** newSL = new SkipNode<T> * [h];\n        \n        //delete the old skip list\n        deleteSkipList(levels,height);\n        delete[] levels;\n\n        //initialize the new skip list\n        levels = newSL;\n        createLevel(0);\n\n        for(int i = 0; i < h; ++i)\n        {\n            traverse = toCopy[i];\n            while(traverse != nullptr)\n            {\n                //initialize pointer\n                 SkipNode<T> * trav = levels[l];\n\n                 //create a key \n                 SkipListKey<T> slk(SkipListKind::Normal,traverse->k->getElement);\n\n                 //insert the node\n                 insertSkipNode(l,slk,trav);\n                \n                 //increment size\n                 ++sz;    \n\n                 traverse = traverse->next;\n            }\n\n\n        }\n      \n    }\n\n\n\ntemplate <typename T>\nSkipListSet<T>::SkipListSet(const SkipListSet& s)\n{\n      copySkipList(s,s.height);\n}\n\n\ntemplate <typename T>\nSkipListSet<T>& SkipListSet<T>::operator=(const SkipListSet& s)\n{\n    return *this;\n}\n\n\ntemplate <typename T>\nbool SkipListSet<T>::isImplemented() const\n{\n    return true;\n}\n\nint nextLevel()\n{\n   return distribution(engine); \n}\n\ntemplate<typename T>\nint skipListSearch(int level, SkipListKey<T> & slk, SkipNode<T> * sn)\n{\n            if(sn->next->k == slk)\n            {\n                 return true;\n            }\n\n            if(sn->next->k < slk)\n            {\n                 return skipListSearch(level, slk, sn->next);\n            }\n\n            \n            if(slk < sn->next->k && level > 0)\n            return  skipListSearch(level - 1, slk, sn->down);\n            \n            \n            return false;\n            \n}\n\ntemplate<typename T>\nvoid SkipListSet<T>::insertSkipNode(int level,SkipListKey<T> & slk, SkipNode<T>* sn)\n{\n  \n   if(sn->next->k < slk)\n    {\n     insertSkipNode(level, slk, sn->next);\n    }\n    \n    if(slk < sn->next->k && level > 0)\n    {\n        insertSkipNode(level -1, slk, sn->down);\n    }\n\n   \n    if(level == 0 && sn->k < slk && slk < sn->next->k)\n    {\n        //Add to bottom level\n        trailer = sn;\n        temp = sn->next;\n        trailer->next = new SkipNode<T>(SkipListKind::Normal, temp, slk.getKey());\n       up = nextLevel();\n        if(up)\n        {\n             downTracker = trailer->next;\n        }\n    }\n    \n    if(up)\n    {\n    \n    if(sn->k < slk && slk < sn->next->k && level > 0)\n       {\n            temp = sn->next;\n             trailer = sn;\n             trailer->next = new SkipNode<T>(SkipListKind::Normal,\n             temp, downTracker, slk.getKey());\n             up = nextLevel();\n             downTracker = trailer->next;\n       \n       }\n\n        if(level == l && up == 1)\n        {\n             int uLevel = l + 1;\n             while(uLevel >= l && up == 1)\n             {\n            createLevel(uLevel);\n             ++l;\n            temp = levels[uLevel]->next;\n             trailer = levels[uLevel];\n             trailer->next = new SkipNode<T>(SkipListKind::Normal,\n             temp, downTracker, slk.getKey());\n            downTracker = trailer->next;\n             up = nextLevel();\n\n             if(up)\n             ++uLevel;\n        }\n        }\n   }\n}\n\ntemplate <typename T>\nvoid SkipListSet<T>::add(const T& element)\n{\n   //initialize pointer\n    SkipNode<T> * trav = levels[l];\n\n    //create a key \n    SkipListKey<T> slk(SkipListKind::Normal,element);\n\n    //insert the node\n    insertSkipNode(l,slk,trav);\n\n    ++sz;    \n\n}\n\n\ntemplate <typename T>\nbool SkipListSet<T>::contains(const T& element) const\n{\n    SkipNode<T> * trav = levels[l];\n    SkipListKey<T> slk(SkipListKind::Normal,element);\n   return skipListSearch(l,slk,trav);\n    \n}\n\n\ntemplate <typename T>\nunsigned int SkipListSet<T>::size() const\n{\n    return sz;\n}\n\n\n\n#endif // SKIPLISTSET_HPP','SkipListSet.hpp',2);
/*!40000 ALTER TABLE `files` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lang`
--

DROP TABLE IF EXISTS `lang`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `lang` (
  `lang_id` int(11) NOT NULL AUTO_INCREMENT,
  `lang` varchar(45) NOT NULL,
  `proj_name` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`lang_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lang`
--

LOCK TABLES `lang` WRITE;
/*!40000 ALTER TABLE `lang` DISABLE KEYS */;
INSERT INTO `lang` VALUES (1,'cpp','template_hash_table');
INSERT INTO `lang` VALUES (2,'cpp','template_skip_list');
/*!40000 ALTER TABLE `lang` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `proj`
--

DROP TABLE IF EXISTS `proj`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `proj` (
  `proj_id` int(11) NOT NULL AUTO_INCREMENT,
  `proj_name` varchar(45) NOT NULL,
  `file_name` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`proj_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `proj`
--

LOCK TABLES `proj` WRITE;
/*!40000 ALTER TABLE `proj` DISABLE KEYS */;
INSERT INTO `proj` VALUES (1,'template_hash_table','HashSet.hpp');
INSERT INTO `proj` VALUES (2,'template_skip_list','SkipListSet.hpp');
/*!40000 ALTER TABLE `proj` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2016-12-13 13:56:52
